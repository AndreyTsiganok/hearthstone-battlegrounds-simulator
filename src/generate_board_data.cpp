#include "board.hpp"
#include "parser.hpp"
#include <string>
#include <fstream>
#include <iomanip>
#include <algorithm>
using namespace std;

// -----------------------------------------------------------------------------
// C++ code generator
// -----------------------------------------------------------------------------

void dump_enum_name(ostream& out, const char* n) {
  bool next_upper = true;
  for (; *n; ++n) {
    if (isalpha(*n) || isdigit(*n)) {
      if (next_upper) {
        out.put((char)toupper(*n));
        next_upper = false;
      } else {
        out.put(*n);
      }
    }
    if (isspace(*n) || *n == '-') {
      next_upper = true;
    }
  }
}
void dump(ostream& out, MinionType type) {
  out << "MinionType::";
  dump_enum_name(out,::name(type));
}
void dump(ostream& out, HeroType hp) {
  out << "HeroType::";
  dump_enum_name(out,::name(hp));
}

void dump(ostream& out, Minion const& m) {
  out << "{";
  out << std::boolalpha;
  dump(out, m.type);
  out << ",";
  out << m.golden << ",";
  out << m.attack << ",";
  out << m.health << ",";
  out << m.taunt << ",";
  out << m.divine_shield << ",";
  out << m.poison << ",";
  out << m.windfury << ",";
  out << m.reborn << ",";
  out << m.deathrattle_murlocs << ",";
  out << m.deathrattle_microbots << ",";
  out << m.deathrattle_golden_microbots << ",";
  out << m.deathrattle_plants << ",";
  out << "}";
}

void dump(ostream& out, Board const& b) {
  out << "{{";
  b.for_each([&](Minion const& m) { dump(out,m); out << ",\n    "; });
  out << "},";
  dump(out, b.hero);
  out << "," << b.use_hero_power << "," << b.level << "," << b.health << "}";
}

void dump_binary(ostream& out, const char* data, int n) {
  for (int i=0; i<n; ++i) {
    out << "0x" << hex << setw(2) << setfill('0') << (int)(unsigned char)data[i] << ",";
  }
}

struct BoardWithTurn {
  Board board;
  int turn = -1;
  std::string label;
};
using Boards = vector<BoardWithTurn>;
bool operator < (BoardWithTurn const& a, BoardWithTurn const& b) {
  return a.turn < b.turn;
}

const bool BINARY = true;

void generate_output(ostream& out, Boards const& boards) {
  out << "#include \"board.hpp\"" << endl;
  out << "// -----------------------------------------------------------------------------" << endl;
  out << "// THIS FILE IS AUTOGENERATED" << endl;
  out << "// -----------------------------------------------------------------------------" << endl;
  out << endl;
  // board data
  if (BINARY) {
    out << "const char board_data[] = {" << endl;
    for (auto const& b : boards) {
      out << dec << "// Turn " << b.turn << ", " << "stats: " << b.board.total_stats();
      if (!b.label.empty()) out << ", " << b.label;
      out << endl;
      dump_binary(out, (const char*)&b.board, sizeof(Board));
      out << endl;
    }
    out << "};" << endl;
  } else {
    out << "const Board board_data[] = {" << endl;
    for (auto const& b : boards) {
      out << "  // turn " << b.turn << endl;
      out << "  ";
      dump(out,b.board);
      out << "," << endl;
    }
    out << "};" << endl;
  }
  out << endl;
  // the boards for each turn
  int turn = 1;
  size_t pos = 0; // first board with this turn number
  out << dec;
  out << "const Board* const boards_for_turn[] = {" << endl;
  for ( ; pos < boards.size() ; ++turn) {
    while (pos < boards.size() && boards[pos].turn < turn) ++pos;
    out << "  static_cast<const Board*>(board_data) + " << pos << "," << " // turn " << turn << endl;
  }
  out << "};" << endl;
  out << "const int num_turns_with_boards = " << (turn-2) << ";" << endl;
}

// -----------------------------------------------------------------------------
// Board parser
// -----------------------------------------------------------------------------

bool parse_board_definition(StringParser& in, Board& board) {
  if (in.match_end()) {
    // empty line or comment
  } else if (in.match("*")) {
    // define minion
    Minion m;
    if (parse_minion(in,m) && in.parse_end()) {
      board.append(m);
    }
  } else if (in.match("board")) {
  } else if (in.match("hp") || in.match("hero-power")) {
    in.match(":"); // optional
    HeroType hero;
    if (parse_hero_type(in, hero) && in.parse_end()) {
      board.hero = hero;
      board.use_hero_power = true;
    }
  } else if (in.match("level")) {
    in.match(":"); // optional
    int n = 0;
    if (in.parse_non_negative(n) && in.parse_end()) {
      board.level = n;
    }
  } else if (in.match("health")) {
    in.match(":"); // optional
    int n = 0;
    if (in.parse_non_negative(n) && in.parse_end()) {
      board.health = n;
    }
  } else {
    return false;
  }
  return true;
}

bool parse_board_with_turn(StringParser& in, BoardWithTurn& board) {
  if (in.match("turn")) {
    in.match(":"); // optional
    int n = 0;
    if (in.parse_non_negative(n)) {
      in.skip_ws();
      board.label = in.str;
      board.turn = n;
    }
    return true;
  }
  return parse_board_definition(in, board.board);
}

void load_boards(istream& lines, const char* filename, Boards& boards) {
  ErrorHandler error(cerr, filename);

  BoardWithTurn board;
  
  while (lines.good()) {
    // get line
    error.line_number++;
    std::string line;
    getline(lines,line);
    StringParser in(line.c_str(), error);

    // parse line
    if (parse_board_with_turn(in, board)) {
      continue;
    } else if (in.peek() == '=') {
      if (board.turn > 0) {
        boards.push_back(board);
      }
      board = BoardWithTurn();
      // board separator
    } else {
      in.unknown("command");
    }
  }
}

// -----------------------------------------------------------------------------
// Main function
// -----------------------------------------------------------------------------

int main(int argc, char const** argv) {
  if (argc <= 1) {
    cout << "Usage: " << argv[0] << " <board files>" << endl;
  } else {
    Boards boards;
    for (int i=1; i<argc; ++i) {
      ifstream in(argv[i]);
      if (!in) {
        cerr << "Error loading file " << argv[i] << endl;
        return 1;
      }
      load_boards(in, argv[i], boards);
    }
    std::sort(boards.begin(), boards.end());
    generate_output(cout, boards);
  }
  return 0;
}

